1.总结几种socket粘包的解包方式：fix length/delimiter based/length field based frame decoder.
尝试举例其应用

什么是粘包和半包问题？
1.粘包问题：指发送两条消息时，比如发送了ABC和DEF，但另一端接收到的却是ABCD，像这种一次性读取了两条数据的情况就叫做粘包（正常情况应该是一条一条读取的）
2.半包问题：当发送的消息是ABC时，另一端却接收到的是AB和C两条消息，像这种情况就叫做半包

为什么会有粘包和半包问题？
这是因为TCP是面向连接的传输协议，TCP传输的数据是以流的形式，而流数据是没有明确的开始结尾边界，所以TCP也没办法判断哪一段流属于一个消息。
发送数据过程：应用程序发送消息包，消息包以数据流形式形式放入缓冲区，等缓冲区的数据流到达一定阈值后，再发送到网络上
接收数据过程：接收到网络过来的数据流，放入缓冲区，缓冲区的数据流到达一定阈值后，通知应用程序进行读取数据

为什么需要缓冲区？
缓冲区又称为缓存，它是内存空间的一部分。也就是说，在内存空间中预留了一定的存储空间，这些存储空间用来缓冲输入或输出的数据，这部分预留的空间就叫做缓冲区。
缓冲区的优势以文件流的写入为例，如果我们不使用缓冲区，那么每次写操作CPU都会和低速存储设备也就是磁盘进行交互，那么整个写入文件的速度就会受制低速
的存储设备（磁盘）。但如果使用缓冲区的话，每次写操作会先将数据保存在高速缓冲区内存上，当缓冲区的数据到达某个阈值之后，再将文件一次性写入到磁盘上。
因为内存的写入速度远远大于磁盘的写入速度，所以当有了缓冲区之后，文件的写入速度就被大大提升了。

粘包的主要原因：
1.发送方每次写入数据 < 套接字（socket）缓冲区大小
2.接收方读取套接字（socket）缓冲区数据不够及时
半包的主要原因：
1.发送方每次写入数据 > 套接字（socket）缓冲区大小
2.发送的数据大于协议的MTU（Maximum Transmission Unit，最大传输单元），因此必须拆包

怎么处理粘包
方式1：fix length
发送方每次发送固定长度的数据，并且不超过缓冲区，接受每次按固定长度接受数据
问题：长度设置不够灵活。当数据比较小时会使用空字符来弥补，会增加网络传输的负担

方式2：delimiter base
发送方在数据包添加特殊的分隔符，用来标记数据包边界
问题：一条请求内不能出现约定的分割符

方式3：length field based frame decoder
发送端将消息按frame进行组织，当请求较长时，可以将其拆分为多个frame，每一个frame包含消息头，其中有固定的长度字段，对frame的头、body数据长度进行标识，
接收端先读取固定大小的长度字段，取得frame的头、body数据的长度，再读取frame的实际的头数据。此外，frame的头部，还会标识当前请求的frame是否已经全部接收
完毕，接收端可以将多个frame合并，最终，取得完整的一个请求。

